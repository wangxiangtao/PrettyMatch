{"name":"Prettymatch","tagline":"Prettymatch","body":"PrettyMatch\r\n===========\r\nPrettyMatch is a String Matching library written in Scala. \r\nIt has sophisticated comparators that perform approximate string matching, measurement of string similarity/distance, index of word pronunciation,semantic distance and sounds-like comparisons. Using an supervised Cleaner and Marcher model PrettyMatch can handle noisy data with good accuracy.\r\n\r\n## Basic algorithms\r\nUseful for approximate string matching and measurement of string distance. All metrics calculate the similarity of two strings as a double with a value between 0 and 1. A value of 0 being completely different and a value of 1 being completely similar.\r\n\r\n* __[FuzzyWuzzy](http://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/)__ \r\n* __[Dice / Sorensen](http://en.wikipedia.org/wiki/Dice%27s_coefficient)__ \r\n* __[Jaccard](http://en.wikipedia.org/wiki/Jaccard_index)__ \r\n* __[Jaro-Winkler](http://en.wikipedia.org/wiki/Jaro-Winkler_distance)__ \r\n* __[Levenshtein](http://en.wikipedia.org/wiki/Levenshtein_distance)__ \r\n* __[Word-level Levenshtein](http://en.wikipedia.org/wiki/Levenshtein_distance)__ \r\n* __[N-Gram](http://en.wikipedia.org/wiki/N-gram)__\r\n* __[Word-level N-Gram](http://en.wikipedia.org/wiki/N-gram)__\r\n* __[Overlap](http://en.wikipedia.org/wiki/Overlap_coefficient)__ \r\n* __[Soundex](http://en.wikipedia.org/wiki/Soundex)__ \r\n* __[Deep Learning-Word2Vec](https://code.google.com/p/word2vec/)__\r\n* __[MinHash](http://en.wikipedia.org/wiki/MinHash)__ \r\n```scala\r\nStringMetric.compareWithJaccard(1)(\"google crayon\", \"goodbye crayon\")       //0.6875\r\nStringMetric.compareWithJaro(\"google crayon\", \"goodbye crayon\")             //0.7863\r\nStringMetric.compareWithJaroWinkler(\"google crayon\", \"goodbye crayon\") \t    //0.8504\r\nStringMetric.compareWithNGramLetter(2)(\"google crayon\", \"goodbye crayon\")   //0.6923\r\nStringMetric.compareWithNGramWord(2)(\"google crayon\", \"goodbye crayon\")     //0.3333\r\nStringMetric.compareWithOverlap(2)(\"google crayon\", \"goodbye crayon\")       //0.7500\r\nStringMetric.compareWithLevenshtein(\"google crayon\", \"goodbye crayon\")\t    //0.7857\r\nStringMetric.compareWithFuzzyWuzzy(\"google crayon\", \"goodbye crayon\")       //0.7900\r\nStringMetric.compareWithSoundex(\"google crayon\", \"goodbye crayon\")          //0.7000\r\nStringMetric.compareWithWordLevenshtein(\"google crayon\", \"goodbye crayon\")  //0.5000\r\nStringMetric.compareWithWord2vec(\"google crayon\", \"goodbye crayon\")         //0.5920\r\nStringMetric.compareWithMinHash(\"google crayon\", \"goodbye crayon\")          //0.3333\r\n```\r\n\r\nYou possibly need to add new comparators by easliy extend StringMetric class and implement the compare() method \r\n\r\n##  Advanced algorithms\r\nAdvanced algorithms can automatically clean and match strings without any customized code and config. it contains \r\n\r\n* __supervised Cleaner__  based on training data, it automatically identify and remove redundant tokens  \r\n* __supervised Matcher__  learn from all the metrics using random forest and properly combine all metrics to build a classifier for matching.  the random forest is automatically optimized by grid search the proper num of trees. \r\n\r\nThe pipeline are shown as below\r\n\r\n![alt tag](https://raw.githubusercontent.com/wangxiangtao/prettymatch/master/pipe.png)\r\n\r\nYou can easily add other cleaners by extend Clearner class and implement the clean() method \r\n\r\nTo train a comprehensive model by all the matrics , you just need to run :\r\n\r\n```scala\r\nval PrettyMatch  = new PrettyMatch \r\nPrettyMatch.run(trainingdata,true)  // The format of trainingdata is a list of tuple which has 3 elements                  \r\n                                    // A tuple contain two strings and one boolean value to indicate they match or not)\r\n                                    // The second parameter indicate use supervised cleaner or not\r\n```\r\n\r\n\r\nIt will generate trained model for comparison and print Confusion Matric by 10 cross validation.\r\n\r\n\r\n##  Example : company name matching\r\nThere are [6000 pairs of comany names](https://drive.google.com/file/d/0B3fXSfbZhqCFcVJDeDJmdmh4Umc/view?usp=sharing\r\n) which contain 1000 matched names and 5000 unmatched names\r\n\r\nUsing it as training data, we run the learning algorithm to get the confusion matric below. \r\n##### Confusion Matric\r\n###### without supervised cleaner\r\n|               | TP            | FP  |\r\n| ------------- |:-------------:| --: |\r\n| Unique        | 4989          | 7   |\r\n| Duplicated    | 991           | 9   |\r\n\r\n###### with supervised cleaner\r\nautomatically identify and clean redundant tokens : LLC, Inc, Company, Corp, Ltd, Corp., Inc., Limited, Group ...\r\n\r\n|               | TP            | FP  |\r\n| ------------- |:-------------:| --: |\r\n| Unique        | 4972          | 6   |\r\n| Duplicated    | 996           | 4   |\r\n\r\n#### Any feedback, ideas, suggestions, success stories etc are more than welcome!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}